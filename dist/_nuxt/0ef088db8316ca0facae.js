(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{172:function(n,e,t){var content=t(188);"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,t(19).default)("00a392c6",content,!0,{sourceMap:!1})},186:function(n){n.exports=JSON.parse('[{"name":"copyWithin","description":" копирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу target. Копия берётся по индексам, задаваемым вторым и третьим аргументами start и end. Аргумент end является необязательным и по умолчанию равен длине массива. ","syntax":"arr.copyWithin(target, start[, end = this.length])","syntaxDescr":"target\\nНачальный индекс позиции цели, куда копировать элементы.\\nstart\\nНачальный индекс позиции источника, откуда начинать копировать элементы.\\nend\\nНеобязательный параметр. Конечный индекс позиции источника, где заканчивать копировать элементы.","func":"[1, 2, 3, 4, 5].copyWithin(0, 3);\\n// [4, 5, 3, 4, 5]\\n\\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\\n// [4, 2, 3, 4, 5]\\n\\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1);\\n// [4, 2, 3, 4, 5]\\n\\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);\\n// {0: 1, 3: 1, length: 5}\\n\\n// Типизированные массивы ES6 являются подклассами Array\\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\\n\\ni32a.copyWithin(0, 2);\\n// Int32Array [3, 4, 5, 4, 5]\\n\\n// На платформах, которые ещё не совместимы с ES6:\\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\\n// Int32Array [4, 2, 3, 4, 5]\\n\\ndocument.getElementById(\'copyWithin\').innerHTML = [1, 2, 3, 4, 5].copyWithin(0, -2, -1)","func2":"\\ndocument.getElementById(\'copyWithin\').innerHTML = \'asdfadsfadfaf\'"},{"name":"entries","description":"озвращает новый объект итератора массива Array Iterator, содержащий пары ключ / значение для каждого индекса в массиве.","syntax":"arr.entries()","syntaxDescr":"","func":"var arr = [\'a\', \'b\', \'c\'];\\nvar eArr = arr.entries();\\n\\nconsole.log(eArr.next().value); // [0, \'a\']\\nconsole.log(eArr.next().value); // [1, \'b\']\\nconsole.log(eArr.next().value); // [2, \'c\']\\n\\ndocument.getElementById(\'entries\').innerHTML = \'хз как вывести сюда, а не в консоль\']\\n","func2":"\\ndocument.getElementById(\'copyWithin\').innerHTML = \'asdfadsfadfaf\'"},{"name":"every","description":"проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.","syntax":"arr.every(callback(currentValue[, index[, array]])[, thisArg])","syntaxDescr":"callback\\nФункция проверки каждого элемента, принимает три аргумента:\\ncurrentValue\\nТекущий обрабатываемый элемент массива.\\nindexНеобязательный\\nИндекс текущего обрабатываемого элемента массива.\\narrayНеобязательный\\nМассив, по которому осуществляется проход.\\nthisArgНеобязательный\\nНеобязательный параметр. Значение, используемое в качестве this при выполнении функции callback.","func":"document.getElementById(\'every\').innerHTML = [12, 5, 8, 130, 44].every(x => x >= 10);"},{"name":"filter","description":"создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.","syntax":"var newArray = arr.filter(callback[, thisArg])\\n\\n//var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])","syntaxDescr":"callback\\nФункция, которая будет вызвана для каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется. В функцию будет передано три аргумента:\\nelement\\nТекущий обрабатываемый элемент в массиве.\\nindexНеобязательный\\nИндекс текущего обрабатываемого элемента в массиве.\\narrayНеобязательный\\nМассив, по которому осуществляется проход.\\nthisArg Необязательный\\nНеобязательный параметр. Значение, используемое в качестве this при вызове функции callback.","func":"var words = [\'spray\', \'limit\', \'elite\', \'exuberant\', \'destruction\', \'present\'];\\n\\nconst result = words.filter(word => word.length > 6);\\n\\nconsole.log(result);\\n\\ndocument.getElementById(\'filter\').innerHTML = result"},{"name":"filter2","description":", точнее просто filter, создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.","func":"var arr = [\\n    { id: 15 },\\n    { id: -1 },\\n    { id: 0 },\\n    { id: 3 },\\n    { id: 12.2 },\\n    { },\\n    { id: null },\\n    { id: NaN },\\n    { id: \'undefined\' }\\n];\\n\\nvar invalidEntries = 0;\\n\\nfunction isNumber(obj) {\\n    return obj!== undefined && typeof(obj) === \'number\' && !isNaN(obj);\\n}\\n\\nfunction filterByID(item) {\\n    if (isNumber(item.id) && item.id !== 0) {\\n        return true;\\n    }\\n    invalidEntries++;\\n    return false;\\n}\\n\\nvar arrByID = arr.filter(filterByID);\\n\\nconsole.log(\'Отфильтрованный массив\\\\n\', arrByID);\\n// Filtered Array\\n// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]\\n\\nconsole.log(\'Количество ошибочных записей = \', invalidEntries);\\n// Number of Invalid Entries = 5\\n\\ndocument.getElementById(\'filter2\').innerHTML = \'Количество ошибочных записей = \'+invalidEntries"},{"name":"flatMap","description":" сначала применяет функцию к каждому элементу, а затем преобразует полученый результат в плоскую структуру и помещает в новый массив. Это идентично map фукнции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно. Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно \\"подняты\\" на указанный уровень depth.","syntax":"var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {\\n\\n// возращает элемент для new_array\\n}[, thisArg])","syntaxDescr":"callback\\nФункция которая производит элементы нового массива, принимает три аргумента:\\n \\ncurrentValue\\nТекущий обрабатываемый элемент массива.\\nindexНеобязательный\\nИндекс обрабатываемого элемента в массиве.\\narrayНеобязательный\\nМассив по которому осуществляется обход.\\nthisArgНеобязательный\\nЗначение используемое в качестве this при вызове функции callback.","func":"let arr1 = [1, 2, 3, 4];\\n\\narr1.map(x => [x * 2]); \\n// [[2], [4], [6], [8]]\\n\\narr1.flatMap(x => [x * 2]);\\n// [2, 4, 6, 8]\\n\\n// выравнивается только один уровень\\narr1.flatMap(x => [[x * 2]]);\\n// [[2], [4], [6], [8]]\\n\\ndocument.getElementById(\'flatMap\').textContent = arr1.flatMap(x => [[x * 2]]);"},{"name":"forEach","description":"выполняет указанную функцию один раз для каждого элемента в массиве.","func":"function logArrayElements(element, index, array) {\\n  console.log(\'a[\' + index + \'] = \' + element);\\n}\\n\\n// Обратите внимание на пропуск по индексу 2, там нет элемента, поэтому он не посещается\\n[2, 5, , 9].forEach(logArrayElements);\\ndocument.getElementById(\'forEach\').innerHTML = [2, 5, , 9].forEach(logArrayElements);"},{"name":"from","description":"создаёт новый экземпляр Array из массивоподобного или итерируемого объекта.","show":false,"func":"// Использование стрелочной функции в качестве функции отображения для\\n\\n// манипулирования элементами\\nArray.from([1, 2, 3], x => x + x); \\n// [2, 4, 6] \\n\\n// Генерирования последовательности чисел\\nArray.from({ length: 5 }, (v, k) => k); \\n// [0, 1, 2, 3, 4]\\n\\ndocument.getElementById(\'from\').innerHTML = Array.from({ length: 5 }, (v, k) => k)"},{"name":"join","description":"объединяет все элементы массива (или массивоподобного объекта) в строку.","show":false,"func":"function f(a, b, c) {\\n  var s = Array.prototype.join.call(arguments);\\n  return s; \\n// \'1,a,true\'\\n}\\n\\ndocument.getElementById(\'join\').innerHTML = f(1, \'a\', true)"},{"name":"map","description":"создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.","show":false,"func":"var numbers = [1, 4, 9];\\nvar doubles = numbers.map(function(num) {\\n  return num * 2;\\n});\\n// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]\\n\\nvar map = Array.prototype.map;\\nvar a = map.call(\'Hello World\', function(x) { return x.charCodeAt(0); });\\n// теперь a равен [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]\\n\\ndocument.getElementById(\'map\').innerHTML = a;"},{"name":"pop","description":"удаляет последний элемент из массива и возвращает его значение.","func":"var myFish = [\'ангел\', \'клоун\', \'мандарин\', \'хирург\'];\\nvar popped = myFish.pop();\\ndocument.getElementById(\'pop\').innerHTML =  popped"},{"name":"push","description":" добавляет один или более элементов в конец массива и возвращает новую длину массива.","func":"var vegetables = [\'пастернак\', \'картошка\'];\\nvar moreVegs = [\'сельдерей\', \'свёкла\'];\\n\\n// Сливает второй массив с первым\\n// Эквивалентно вызову vegetables.push(\'сельдерей\', \'свёкла\');\\nArray.prototype.push.apply(vegetables, moreVegs);\\ndocument.getElementById(\'push\').innerHTML =vegetables;"},{"name":"shift","description":"удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.","func":"var myFish = [\'ангел\', \'клоун\', \'мандарин\', \'хирург\'];\\n\\nvar shifted = myFish.shift();\\n\\ndocument.getElementById(\'shift\').innerHTML = shifted;"},{"name":"slice","description":"возвращает новый массив, содержащий копию части исходного массива.","func":"// Используя slice, создаём newCar из myCar.\\nvar myHonda = { color: \'красный\', wheels: 4, engine: { cylinders: 4, size: 2.2 } };\\nvar myCar = [myHonda, 2, \'в хорошем состоянии\', \'приобретена в 1997\'];\\nvar newCar = myCar.slice(0, 2);\\n\\n// Изменяем цвет myHonda.\\nmyHonda.color = \'багровый\';\\n\\ndocument.getElementById(\'slice\').innerHTML = \'newCar = \' + JSON.stringify(newCar);"},{"name":"some","description":"проверяет, удовлетворяет ли хоть какой-нибудь элемент массива условию, заданному в передаваемой функции.","func":"[2, 5, 8, 1, 4].some(elem => elem > 10);  // false\\n[12, 5, 8, 1, 4].some(elem => elem > 10); // true\\n\\ndocument.getElementById(\'some\').textContent = [12, 5, 8, 1, 4].some(elem => elem > 10);"},{"name":"sort","description":"на месте сортирует элементы массива и возвращает отсортированный массив... разумнее использовать map для сортировки. Идея состоит в том, чтобы обойти массив один раз, чтобы извлечь фактические значения, используемые для сортировки, во временный массив, отсортировать временный массив, а затем обойти временный массив для получения правильного порядка.","func":"// массив для сортировки\\nvar list = [\'Дельта\', \'альфа\', \'ЧАРЛИ\', \'браво\'];\\n\\n// временный массив содержит объекты с позицией и значением сортировки\\nvar mapped = list.map(function(el, i) { \\nreturn { index: i, value: el.toLowerCase() }; \\n});\\n\\n// сортируем массив, содержащий уменьшенные значения\\nmapped.sort(function(a, b) { \\n  if (a.value > b.value) { \\n    return 1; } \\n  if (a.value < b.value) { \\n    return -1; } \\n  return 0; \\n});\\n\\n// контейнер для результа\\nvar result = mapped.map(function(el) {\\n  return list[el.index];\\n});\\n\\ndocument.getElementById(\'sort\').textContent = result;"},{"name":"splice","description":"изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.","func":"var myFish = [\'angel\', \'clown\', \'mandarin\', \'sturgeon\'];\\nvar removed = myFish.splice(2, 0, \'drum\');\\n\\n// myFish равен [\\"angel\\", \\"clown\\", \\"drum\\", \\"mandarin\\", \\"sturgeon\\"] \\n// removed равен [], ничего не удалено\\n\\nvar myFish = [\'angel\', \'clown\', \'trumpet\', \'sturgeon\'];\\nvar removed = myFish.splice(0, 2, \'parrot\', \'anemone\', \'blue\');\\n\\n// myFish равен [\\"parrot\\", \\"anemone\\", \\"blue\\", \\"trumpet\\", \\"sturgeon\\"] \\n// removed равен [\\"angel\\", \\"clown\\"]\\n\\ndocument.getElementById(\'splice\').textContent = myFish"},{"name":"unshift","description":"добавляет один или более элементов в начало массива и возвращает новую длину массива","func":"var arr = [1, 2];\\n\\narr.unshift(0); // результат вызова равен 3, новой длине массива\\n// arr равен [0, 1, 2]\\n\\narr.unshift(-2, -1); // = 5\\n// arr равен [-2, -1, 0, 1, 2]\\n\\ndocument.getElementById(\'unshift\').textContent = arr.unshift(-2, -1);"}]')},187:function(n,e,t){"use strict";var r=t(172);t.n(r).a},188:function(n,e,t){(n.exports=t(18)(!1)).push([n.i,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n/*!!!!!!!!!!!!!!! НАДО ВЗЯТЬ ИЗ ЭНГРИБЕРДС */.fade-enter-active,.fade-leave-active{transition:all .25s cubic-bezier(1,.5,.8,1)}.fade-enter,.fade-leave-to{transform:translateX(100px);opacity:0}",""])},211:function(n,e,t){"use strict";t.r(e);var r=t(186),o={name:"arrayz",components:{task:function(){return t.e(13).then(t.bind(null,225))},convertToJson:function(){return t.e(16).then(t.bind(null,220))}},data:function(){return{items:r}}},l=(t(187),t(2)),component=Object(l.a)(o,function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"container"},[n._m(0),n._v(" "),n._m(1),n._v(" "),n._m(2),n._v(" "),n._l(n.items,function(n){return t("task",{key:n.name,attrs:{name:n.name,syntax:n.syntax,syntaxDescr:n.syntaxDescr,description:n.description,func:n.func,func2:n.func2}})}),n._v(" "),t("convertToJson")],2)},[function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"titlePage"},[e("h1",[this._v("Array Methods")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("blockquote",{staticClass:"blockquote text-right"},[e("p",{staticClass:"mb-0"},[this._v("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.")]),this._v(" "),e("footer",{staticClass:"blockquote-footer"},[this._v("Someone famous in\n\t      "),e("cite",{attrs:{title:"Source Title"}},[this._v("Source Title")])])])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"workbookText"},[t("h3",[n._v("What I realized here?")]),n._v(" "),t("ul",[t("li",[n._v("Component with form, with little bit of validation. This form take normally written functions and returns functions in JSON string. I need this to save all my lessons in JSON. And next in all task (component) I take  JavaScript code represented as a string and lunch from button in appropriate task-block ")]),n._v(" "),t("li",[n._v('Фух блядь работает! Я добавил метод filter для массивов. Взял пример выполнения этого метода -- код в 3 строчки, рузултат выполнения записывался в переменную result. Через окно textarea я вставил этот код, по нажатию на кнопку я получил отформатированный под строку json\'a текст. Перед закрывающими кавычками я вставил свое "а в строчку вывода результата я напишу это: (result)" '),t("small",[n._v("document.getElementById('filter').innerHTML = result")]),n._v(". Ну и полученный результат я вставил в json -- все заработало! ")]),n._v(" "),t("li",[n._v('Вставляю в поле ниже код функции. Нажимаю "Convert to JSON". Получаю строку соответствующую JSON. В самом конце, перед закрывающимися кавычками вставляю: '),t("small",[t("mark",[n._v("document.getElementById(' имя в json'e ').innerHTML = \"result\"")])]),n._v(" -- т.е. добавляю, что нужно полученный результат вывести в соответствующем блоке с соответствующим ID. Полученным уже дополняю json-файл.  ")])])])}],!1,null,null,null);e.default=component.exports}}]);