(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{350:function(n){n.exports=JSON.parse('[{"name":"copyWithin","description":" копирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу target. Копия берётся по индексам, задаваемым вторым и третьим аргументами start и end. Аргумент end является необязательным и по умолчанию равен длине массива. ","syntax":"arr.copyWithin(target, start[, end = this.length])","syntaxDescr":"target\\nНачальный индекс позиции цели, куда копировать элементы.\\nstart\\nНачальный индекс позиции источника, откуда начинать копировать элементы.\\nend\\nНеобязательный параметр. Конечный индекс позиции источника, где заканчивать копировать элементы.","func":"[1, 2, 3, 4, 5].copyWithin(0, 3);\\n// [4, 5, 3, 4, 5]\\n\\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1);\\n// [4, 2, 3, 4, 5]\\n\\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);\\n// {0: 1, 3: 1, length: 5}\\n\\n// Типизированные массивы ES6 являются подклассами Array\\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\\n\\ni32a.copyWithin(0, 2);\\n// Int32Array [3, 4, 5, 4, 5]\\n\\n// На платформах, которые ещё не совместимы с ES6:\\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\\n// Int32Array [4, 2, 3, 4, 5]\\n\\ndocument.getElementById(\'copyWithin\').textContent = [1, 2, 3, 4, 5].copyWithin(0, -3, -1)","funcTwo":"\\ndocument.getElementById(\'copyWithin\').textContent = [1, 2, 3, 4, 5].copyWithin(0, 3, 4);\\n// [4, 2, 3, 4, 5]\'"},{"name":"entries","description":"возвращает новый объект итератора массива Array Iterator, содержащий пары ключ / значение для каждого индекса в массиве.","syntax":"arr.entries()","syntaxDescr":"","func":"var arr = [\'a\', \'b\', \'c\'];\\nvar eArr = arr.entries();\\n\\nconsole.log(eArr.next().value); // [0, \'a\']\\nconsole.log(eArr.next().value); // [1, \'b\']\\nconsole.log(eArr.next().value); // [2, \'c\']\\n\\ndocument.getElementById(\'entries\').textContent = [1, \'b\'] + \' - где-то так\';","funcTwo":"\\ndocument.getElementById(\'entries\').textContent = \'Второго примера нету\'"},{"name":"every","description":"проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.","syntax":"arr.every(callback(currentValue[, index[, array]])[, thisArg])","syntaxDescr":"callback\\nФункция проверки каждого элемента, принимает три аргумента:\\ncurrentValue\\nТекущий обрабатываемый элемент массива.\\nindexНеобязательный\\nИндекс текущего обрабатываемого элемента массива.\\narrayНеобязательный\\nМассив, по которому осуществляется проход.\\nthisArgНеобязательный\\nНеобязательный параметр. Значение, используемое в качестве this при выполнении функции callback.","func":"document.getElementById(\'every\').textContent = [12, 5, 8, 130, 44].every(x => x >= 10);","funcTwo":"document.getElementById(\'every\').textContent = [12, 54, 18, 130, 44].every(elem => elem >= 10);"},{"name":"filter","description":"создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.","syntax":"var newArray = arr.filter(callback[, thisArg])\\n\\n//var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])","syntaxDescr":"callback\\nФункция, которая будет вызвана для каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется. В функцию будет передано три аргумента:\\nelement\\nТекущий обрабатываемый элемент в массиве.\\nindexНеобязательный\\nИндекс текущего обрабатываемого элемента в массиве.\\narrayНеобязательный\\nМассив, по которому осуществляется проход.\\nthisArg Необязательный\\nНеобязательный параметр. Значение, используемое в качестве this при вызове функции callback.","func":"var words = [\'spray\', \'limit\', \'elite\', \'exuberant\', \'destruction\', \'present\'];\\n\\nconst result = words.filter(word => word.length > 6);\\n\\nconsole.log(result);\\n\\ndocument.getElementById(\'filter\').textContent = result","funcTwo":"var arr = [\\n    { id: 15 },\\n    { id: -1 },\\n    { id: 0 },\\n    { id: 3 },\\n    { id: 12.2 },\\n    { },\\n    { id: null },\\n    { id: NaN },\\n    { id: \'undefined\' }\\n];\\n\\nvar invalidEntries = 0;\\n\\nfunction isNumber(obj) {\\n    return obj!== undefined && typeof(obj) === \'number\' && !isNaN(obj);\\n}\\n\\nfunction filterByID(item) {\\n    if (isNumber(item.id) && item.id !== 0) {\\n        return true;\\n    }\\n    invalidEntries++;\\n    return false;\\n}\\n\\nvar arrByID = arr.filter(filterByID);\\n\\nconsole.log(\'Отфильтрованный массив\\\\n\', arrByID);\\n// Filtered Array\\n// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]\\n\\nconsole.log(\'Количество ошибочных записей = \', invalidEntries);\\n// Number of Invalid Entries = 5\\n\\ndocument.getElementById(\'filter\').textContent = \'Количество ошибочных записей = \'+invalidEntries"},{"name":"flatMap","description":" сначала применяет функцию к каждому элементу, а затем преобразует полученый результат в плоскую структуру и помещает в новый массив. Это идентично map фукнции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно. Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно \\"подняты\\" на указанный уровень depth.","syntax":"var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {\\n\\n// возращает элемент для new_array\\n}[, thisArg])","syntaxDescr":"callback\\nФункция которая производит элементы нового массива, принимает три аргумента:\\n \\ncurrentValue\\nТекущий обрабатываемый элемент массива.\\nindexНеобязательный\\nИндекс обрабатываемого элемента в массиве.\\narrayНеобязательный\\nМассив по которому осуществляется обход.\\nthisArgНеобязательный\\nЗначение используемое в качестве this при вызове функции callback.","func":"let arr1 = [1, 2, 3, 4];\\n\\narr1.map(x => [x * 2]); \\n// [[2], [4], [6], [8]]\\n\\narr1.flatMap(x => [x * 2]);\\n// [2, 4, 6, 8]\\n\\n// выравнивается только один уровень\\narr1.flatMap(x => [[x * 2]]);\\n// [[2], [4], [6], [8]]\\n\\ndocument.getElementById(\'flatMap\').textContent = arr1.flatMap(x => [[x * 2]]);","funcTwo":"let arr1 = [\\"it\'s Sunny in\\", \\"\\", \\"California\\"];\\n\\narr1.map(x => x.split(\\" \\"));\\n// [[\\"it\'s\\",\\"Sunny\\",\\"in\\"],[\\"\\"],[\\"California\\"]]\\n\\ndocument.getElementById(\'flatMap\').textContent = arr1.flatMap(x => x.split(\\" \\"));\\n\\n// [\\"it\'s\\",\\"Sunny\\",\\"in\\", \\"\\", \\"California\\"]"},{"name":"forEach","description":"выполняет указанную функцию один раз для каждого элемента в массиве.","syntax":"arr.forEach(function callback(currentValue, index, array) {\\n    //your iterator\\n}[, thisArg]);","syntaxDescr":"callback\\nФункция, которая будет вызвана для каждого элемента массива; в нее будет передано три аргумента:\\ncurrentValue\\nТекущий обрабатываемый элемент в массиве.\\nindexНеобязательный\\nИндекс текущего обрабатываемого элемента в массиве.\\narrayНеобязательный\\nМассив, по которому осуществляется проход.\\nthisArg\\nНеобязательный параметр. Значение, используемое в качестве this при вызове функции callback.","func":"var arrResult = []\\nfunction logArrayElements(element, index, array) {\\n  arrResult.push(\' \' + \'a[\' + index + \'] = \' + element);\\n}\\n\\n// Обратите внимание на пропуск по индексу 2, там нет элемента, поэтому он не посещается\\n[2, 5, , 9].forEach(logArrayElements);\\ndocument.getElementById(\'forEach\').textContent = arrResult;","funcTwo":"function copy(o) {\\n  var copy = Object.create(Object.getPrototypeOf(o));\\n  var propNames = Object.getOwnPropertyNames(o);\\n\\n  propNames.forEach(function(name) {\\n    var desc = Object.getOwnPropertyDescriptor(o, name);\\n    Object.defineProperty(copy, name, desc);\\n  });\\n\\n  return copy;\\n}\\n\\nvar o1 = { a: 1, b: 2 };\\nvar o2 = copy(o1); // теперь o2 выглядит также, как и o1\\ndocument.getElementById(\'forEach\').textContent = JSON.stringify(o2);"},{"name":"from","description":"создаёт новый экземпляр Array из массивоподобного или итерируемого объекта.","syntax":"Array.from(arrayLike[, mapFn[, thisArg]])","syntaxDescr":"arrayLike\\nМассивоподобный или итерируемый объект, преобразуемый в массив.\\nmapFn\\nНеобязательный параметр. Отображающая функция, вызываемая для каждого элемента массива.\\nthisArg\\nНеобязательный параметр. Значение, используемое в качестве this при выполнении функции mapFn.","func":"// Использование стрелочной функции в качестве функции отображения для\\n\\n// манипулирования элементами\\nArray.from([1, 2, 3], x => x + x); \\n// [2, 4, 6] \\n\\n// Генерирования последовательности чисел\\nArray.from({ length: 5 }, (v, k) => k); \\n// [0, 1, 2, 3, 4]\\n\\ndocument.getElementById(\'from\').textContent = Array.from({ length: 5 }, (v, k) => k)","funcTwo":"function f() {\\n  return Array.from(arguments);\\n}\\n\\ndocument.getElementById(\'from\').textContent =  f(1, 2, 3); \\n// [1, 2, 3]"},{"name":"join","description":"объединяет все элементы массива (или массивоподобного объекта) в строку.","syntax":"arr.join([separator])","syntaxDescr":"separator Необязательный\\nОпределяет строку, разделяющую элементы массива. В случае необходимости тип разделителя приводится к типу Строка. Если он не задан, элементы массива разделяются запятой \',\'. Если разделитель - пустая строка, элементы массива ничем не разделяются в возвращаемой строке.","func":"function f(a, b, c) {\\n  var s = Array.prototype.join.call(arguments);\\n  return s; \\n// \'1,a,true\'\\n}\\n\\ndocument.getElementById(\'join\').textContent = f(1, \'a\', true)"},{"name":"map","description":"создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.","syntax":"var new_array = arr.map(function callback(currentValue, index, array) { \\n    // Возвращает элемент для new_array \\n}[, thisArg])","syntaxDescr":"callback\\nФункция, создающая элемент в новом массиве, принимает три аргумента:\\ncurrentValue\\nТекущий обрабатываемый элемент массива.\\nindex\\nИндекс текущего обрабатываемого элемента в массиве.\\narray\\nМассив, по которому осуществляется проход.\\nthisArg\\nНеобязательный параметр. Значение, используемое в качестве this при вызове функции callback.","func":"var map = Array.prototype.map;\\nvar a = map.call(\'Hello World\', function(x) { return x.charCodeAt(0); });\\n// теперь a равен [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]\\n\\ndocument.getElementById(\'map\').textContent = a;","funcTwo":"var numbers = [1, 4, 9];\\nvar doubles = numbers.map(function(num) {\\n  return num * 2;\\n});\\n// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]\\n\\ndocument.getElementById(\'map\').textContent = doubles"},{"name":"pop","description":"удаляет последний элемент из массива и возвращает его значение.","syntax":"arr.pop()","func":"var myFish = [\'ангел\', \'клоун\', \'мандарин\', \'хирург\'];\\nvar popped = myFish.pop();\\ndocument.getElementById(\'pop\').textContent =  popped"},{"name":"push","description":" добавляет один или более элементов в конец массива и возвращает новую длину массива.","syntax":"arr.push(element1, ..., elementN)","syntaxDescr":"elementN\\nЭлементы, добавляемые в конец массива.","func":"var vegetables = [\'пастернак\', \'картошка\'];\\nvar moreVegs = [\'сельдерей\', \'свёкла\'];\\n\\n// Сливает второй массив с первым\\n// Эквивалентно вызову vegetables.push(\'сельдерей\', \'свёкла\');\\nArray.prototype.push.apply(vegetables, moreVegs);\\ndocument.getElementById(\'push\').textContent =vegetables;"},{"name":"shift","description":"удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.","syntax":"arr.shift()","func":"var myFish = [\'ангел\', \'клоун\', \'мандарин\', \'хирург\'];\\n\\nvar shifted = myFish.shift();\\n\\ndocument.getElementById(\'shift\').textContent = shifted;"},{"name":"slice","description":"возвращает новый массив, содержащий копию части исходного массива.","syntax":"arr.slice([begin[, end]])","syntaxDescr":"begin Необязательный\\nИндекс (счёт начинается с нуля), по которому начинать извлечение.\\nЕсли индекс отрицательный, begin указывает смещение от конца последовательности. Вызов slice(-2) извлечёт два последних элемента последовательности.\\nЕсли begin неопределен, slice() начинает работать с индекса 0.\\nЕсли begin больше длины последовательности вернется пустой массив.\\nend Необязательный\\nИндекс (счёт начинается с нуля), по которому заканчивать извлечение. Метод slice() извлекает элементы с индексом меньше end.\\nВызов slice(1, 4) извлечёт элементы со второго по четвёртый (элементы по индексам 1, 2 и 3).\\nЕсли индекс отрицательный, end указывает смещение от конца последовательности. Вызов slice(2, -1) извлечёт из последовательности элементы начиная с третьего элемента с начала и заканчивая вторым с конца.\\nЕсли end опущен, slice() извлекает все элементы до конца последовательности (arr.length).","func":"// Используя slice, создаём newCar из myCar.\\nvar myHonda = { color: \'красный\', wheels: 4, engine: { cylinders: 4, size: 2.2 } };\\nvar myCar = [myHonda, 2, \'в хорошем состоянии\', \'приобретена в 1997\'];\\nvar newCar = myCar.slice(0, 2);\\n\\n// Изменяем цвет myHonda.\\nmyHonda.color = \'багровый\';\\n\\ndocument.getElementById(\'slice\').textContent = \'newCar = \' + JSON.stringify(newCar);","funcTwo":"var unboundSlice = Array.prototype.slice;\\nvar slice = Function.prototype.call.bind(unboundSlice);\\n\\nfunction list() {\\n  return slice(arguments, 0);\\n}\\n\\nvar list1 = list(1, 2, 3); // [1, 2, 3]\\n\\ndocument.getElementById(\'slice\').textContent = list1;"},{"name":"some","description":"проверяет, удовлетворяет ли хоть какой-нибудь элемент массива условию, заданному в передаваемой функции.","syntax":"arr.some(callback(currentValue[, index[, array]])[, thisArg])","syntaxDescr":"callback\\nФункция проверки каждого элемента, принимает три аргумента:\\ncurrentValue\\nТекущий обрабатываемый элемент массива.\\nindexНеобязательный\\nИндекс текущего обрабатываемого элемента массива.\\narrayНеобязательный\\nМассив, по которому осуществляется проход.\\nthisArgНеобязательный\\nНеобязательный параметр. Значение, используемое в качестве this при выполнении функции callback.","func":"[2, 5, 8, 1, 4].some(elem => elem > 10);  // false\\n[12, 5, 8, 1, 4].some(elem => elem > 10); // true\\n\\ndocument.getElementById(\'some\').textContent = [12, 5, 8, 1, 4].some(elem => elem > 10);"},{"name":"sort","description":"на месте сортирует элементы массива и возвращает отсортированный массив... разумнее использовать map для сортировки. Идея состоит в том, чтобы обойти массив один раз, чтобы извлечь фактические значения, используемые для сортировки, во временный массив, отсортировать временный массив, а затем обойти временный массив для получения правильного порядка.","syntax":"arr.sort([compareFunction])","syntaxDescr":"compareFunction\\nНеобязательный параметр. Указывает функцию, определяющую порядок сортировки. Если опущен, массив сортируется в соответствии со значениями кодовых точек каждого символа Unicode, полученных путём преобразования каждого элемента в строку.","func":"// массив для сортировки\\nvar list = [\'Дельта\', \'альфа\', \'ЧАРЛИ\', \'браво\'];\\n\\n// временный массив содержит объекты с позицией и значением сортировки\\nvar mapped = list.map(function(el, i) { \\nreturn { index: i, value: el.toLowerCase() }; \\n});\\n\\n// сортируем массив, содержащий уменьшенные значения\\nmapped.sort(function(a, b) { \\n  if (a.value > b.value) { \\n    return 1; } \\n  if (a.value < b.value) { \\n    return -1; } \\n  return 0; \\n});\\n\\n// контейнер для результа\\nvar result = mapped.map(function(el) {\\n  return list[el.index];\\n});\\n\\ndocument.getElementById(\'sort\').textContent = result;"},{"name":"splice","description":"изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.","syntax":"array.splice(start, deleteCount[, item1[, item2[, ...]]])","syntaxDescr":"start\\nИндекс, по которому начинает изменять массив. Если больше длины массива, реальный индекс будет установлен на длину массива. Если отрицателен, указывает индекс элемента с конца.\\ndeleteCount\\nЦелое число, показывающее количество старых удаляемых из массива элементов. Если deleteCount равен 0, элементы не удаляются. В этом случае вы должны указать как минимум один новый элемент. Если deleteCount больше количества элементов, оставшихся в массиве, начиная с индекса start, то будут удалены все элементы до конца массива.\\nitemN\\nНеобязательные параметры. Добавляемые к массиву элементы. Если вы не укажете никакого элемента, splice() просто удалит элементы из массива.","func":"var myFish = [\'angel\', \'clown\', \'mandarin\', \'sturgeon\'];\\nvar removed = myFish.splice(2, 0, \'drum\');\\n\\n// myFish равен [\\"angel\\", \\"clown\\", \\"drum\\", \\"mandarin\\", \\"sturgeon\\"] \\n// removed равен [], ничего не удалено\\n\\nvar myFish = [\'angel\', \'clown\', \'trumpet\', \'sturgeon\'];\\nvar removed = myFish.splice(0, 2, \'parrot\', \'anemone\', \'blue\');\\n\\n// myFish равен [\\"parrot\\", \\"anemone\\", \\"blue\\", \\"trumpet\\", \\"sturgeon\\"] \\n// removed равен [\\"angel\\", \\"clown\\"]\\n\\ndocument.getElementById(\'splice\').textContent = myFish"},{"name":"unshift","description":"добавляет один или более элементов в начало массива и возвращает новую длину массива","syntax":"arr.unshift([element1[, ...[, elementN]]])","syntaxDescr":"element1, ..., elementN\\nНеобязательные параметры. Элементы, добавляемые в начало массива.","func":"var arr = [1, 2];\\n\\narr.unshift(0); // результат вызова равен 3, новой длине массива\\n// arr равен [0, 1, 2]\\n\\narr.unshift(-2, -1); // = 5\\n// arr равен [-2, -1, 0, 1, 2]\\n\\ndocument.getElementById(\'unshift\').textContent = arr.unshift(-2, -1);"}]')},351:function(n,e,t){var content=t(376);"string"==typeof content&&(content=[[n.i,content,""]]),content.locals&&(n.exports=content.locals);(0,t(29).default)("00a392c6",content,!0,{sourceMap:!1})},375:function(n,e,t){"use strict";var r=t(351);t.n(r).a},376:function(n,e,t){(n.exports=t(28)(!1)).push([n.i,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n/*!!!!!!!!!!!!!!! НАДО ВЗЯТЬ ИЗ ЭНГРИБЕРДС */.fade-enter-active,.fade-leave-active{transition:all .25s cubic-bezier(1,.5,.8,1)}.fade-enter,.fade-leave-to{transform:translateX(100px);opacity:0}",""])},417:function(n,e,t){"use strict";t.r(e);var r=t(350),o={name:"arrayz",components:{task:function(){return t.e(0).then(t.bind(null,441))},convertToJson:function(){return t.e(1).then(t.bind(null,434))}},data:function(){return{items:r}}},c=(t(375),t(2)),component=Object(c.a)(o,function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"container"},[t("br"),n._v(" "),n._m(0),n._v(" "),n._m(1),n._v(" "),n._m(2),n._v(" "),n._l(n.items,function(n){return t("task",{key:n.name,attrs:{name:n.name,syntax:n.syntax,syntaxDescr:n.syntaxDescr,description:n.description,func:n.func,funcTwo:n.funcTwo}})})],2)},[function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"titlePage"},[e("h1",[this._v("Array Methods")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("blockquote",{staticClass:"blockquote text-right"},[e("p",{staticClass:"mb-0"},[this._v("Не ошибается тот, кто ничего не делает.")]),this._v(" "),e("footer",{staticClass:"blockquote-footer"},[this._v("Мудрость\n\t      "),e("cite",{attrs:{title:"Source Title"}})])])},function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"workbookText"},[e("br"),this._v(" "),e("ul",[e("li",[this._v("Also I made mini-cheatsheets: just name and description for Array's methods - "),e("a",{staticClass:"navbar-brand text-default",attrs:{href:"/cheatsheet/arrayzmini"}},[this._v("Array to Print")])])])])}],!1,null,null,null);e.default=component.exports}}]);