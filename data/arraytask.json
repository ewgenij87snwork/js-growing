[
{
	"name": "concat",
	"description": "возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.",
	"show": false,
	"func": "var alpha = ['a', 'b', 'c'];document.getElementById('concat').innerHTML = alpha.concat(1, [2, 3]);"
},
{
	"name": "copyWithin",
	"description": " копирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу target. Копия берётся по индексам, задаваемым вторым и третьим аргументами start и end. Аргумент end является необязательным и по умолчанию равен длине массива. <small><i>arr.copyWithin(target, start[, end = this.length])</i></small>",
	"show": false,
	"func": "[1, 2, 3, 4, 5].copyWithin(0, 3);\n// [4, 5, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);\n// [4, 2, 3, 4, 5]\n\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1);\n// [4, 2, 3, 4, 5]\n\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);\n// {0: 1, 3: 1, length: 5}\n\n// Типизированные массивы ES6 являются подклассами Array\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\n\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// На платформах, которые ещё не совместимы с ES6:\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n// Int32Array [4, 2, 3, 4, 5]\n\ndocument.getElementById('copyWithin').innerHTML = [1, 2, 3, 4, 5].copyWithin(0, -2, -1)"
},
{
	"name": "every",
	"description": "проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.",
	"show": false,
	"func": "document.getElementById('every').innerHTML = [12, 5, 8, 130, 44].every(x => x >= 10);"
},
{
	"name": "entries",
	"description": "озвращает новый объект итератора массива Array Iterator, содержащий пары ключ / значение для каждого индекса в массиве.",
	"show": false,
	"func": "var arr = ['a', 'b', 'c'];\nvar eArr = arr.entries();\n\nconsole.log(eArr.next().value); // [0, 'a']\nconsole.log(eArr.next().value); // [1, 'b']\nconsole.log(eArr.next().value); // [2, 'c']\n\ndocument.getElementById('entries').innerHTML = eArr.next().value\n"
},
{
	"name": "filter",
	"description": "создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.",
	"show": false,
	"func": "var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\n\nconst result = words.filter(word => word.length > 6);\n\nconsole.log(result);\n\ndocument.getElementById('filter').innerHTML = result"
},
{
	"name": "filter2",
	"description": ", точнее просто filter, создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.",
	"show": false,
	"func": "var arr = [\n    { id: 15 },\n    { id: -1 },\n    { id: 0 },\n    { id: 3 },\n    { id: 12.2 },\n    { },\n    { id: null },\n    { id: NaN },\n    { id: 'undefined' }\n];\n\nvar invalidEntries = 0;\n\nfunction isNumber(obj) {\n    return obj!== undefined && typeof(obj) === 'number' && !isNaN(obj);\n}\n\nfunction filterByID(item) {\n    if (isNumber(item.id) && item.id !== 0) {\n        return true;\n    }\n    invalidEntries++;\n    return false;\n}\n\nvar arrByID = arr.filter(filterByID);\n\nconsole.log('Отфильтрованный массив\\n', arrByID);\n// Filtered Array\n// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]\n\nconsole.log('Количество ошибочных записей = ', invalidEntries);\n// Number of Invalid Entries = 5\n\ndocument.getElementById('filter2').innerHTML = 'Количество ошибочных записей = '+invalidEntries"
},
{
	"name": "forEach",
	"description": "выполняет указанную функцию один раз для каждого элемента в массиве.",
	"func": "function logArrayElements(element, index, array) {\n  console.log('a[' + index + '] = ' + element);\n}\n\n// Обратите внимание на пропуск по индексу 2, там нет элемента, поэтому он не посещается\n[2, 5, , 9].forEach(logArrayElements);\ndocument.getElementById('forEach').innerHTML = [2, 5, , 9].forEach(logArrayElements);"
},
{
	"name": "from",
	"description": "создаёт новый экземпляр Array из массивоподобного или итерируемого объекта.",
	"show": false,
	"func": "// Использование стрелочной функции в качестве функции отображения для\n\n// манипулирования элементами\nArray.from([1, 2, 3], x => x + x); \n// [2, 4, 6] \n\n// Генерирования последовательности чисел\nArray.from({ length: 5 }, (v, k) => k); \n// [0, 1, 2, 3, 4]\n\ndocument.getElementById('from').innerHTML = Array.from({ length: 5 }, (v, k) => k)"
},
{
	"name": "join",
	"description": "объединяет все элементы массива (или массивоподобного объекта) в строку.",
	"show": false,
	"func": "function f(a, b, c) {\n  var s = Array.prototype.join.call(arguments);\n  return s; \n// '1,a,true'\n}\n\ndocument.getElementById('join').innerHTML = f(1, 'a', true)"
},
{
	"name": "map",
	"description": "создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.",
	"show": false,
	"func": "var numbers = [1, 4, 9];\nvar doubles = numbers.map(function(num) {\n  return num * 2;\n});\n// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]\n\nvar map = Array.prototype.map;\nvar a = map.call('Hello World', function(x) { return x.charCodeAt(0); });\n// теперь a равен [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]\n\ndocument.getElementById('map').innerHTML = a;"
},
{
	"name": "pop",
	"description": "удаляет последний элемент из массива и возвращает его значение.",
	"func": "var myFish = ['ангел', 'клоун', 'мандарин', 'хирург'];\nvar popped = myFish.pop();\ndocument.getElementById('pop').innerHTML =  popped"
},
{
	"name": "push",
	"description": " добавляет один или более элементов в конец массива и возвращает новую длину массива.",
	"func": "var vegetables = ['пастернак', 'картошка'];\nvar moreVegs = ['сельдерей', 'свёкла'];\n\n// Сливает второй массив с первым\n// Эквивалентно вызову vegetables.push('сельдерей', 'свёкла');\nArray.prototype.push.apply(vegetables, moreVegs);\ndocument.getElementById('push').innerHTML =vegetables;"
},
{
	"name": "shift",
	"description": "удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.",
	"func": "var myFish = ['ангел', 'клоун', 'мандарин', 'хирург'];\n\nvar shifted = myFish.shift();\n\ndocument.getElementById('shift').innerHTML = shifted;"
},
{
	"name": "slice",
	"description": "возвращает новый массив, содержащий копию части исходного массива.",
	"func": "// Используя slice, создаём newCar из myCar.\nvar myHonda = { color: 'красный', wheels: 4, engine: { cylinders: 4, size: 2.2 } };\nvar myCar = [myHonda, 2, 'в хорошем состоянии', 'приобретена в 1997'];\nvar newCar = myCar.slice(0, 2);\n\n// Изменяем цвет myHonda.\nmyHonda.color = 'багровый';\n\ndocument.getElementById('slice').innerHTML = 'newCar = ' + JSON.stringify(newCar);"
},
{
	"name": "some",
	"description": "проверяет, удовлетворяет ли хоть какой-нибудь элемент массива условию, заданному в передаваемой функции.",
	"func": "[2, 5, 8, 1, 4].some(elem => elem > 10);  // false\n[12, 5, 8, 1, 4].some(elem => elem > 10); // true\n\ndocument.getElementById('some').textContent = [12, 5, 8, 1, 4].some(elem => elem > 10);"
},
{
	"name": "sort",
	"description": "на месте сортирует элементы массива и возвращает отсортированный массив... разумнее использовать map для сортировки. Идея состоит в том, чтобы обойти массив один раз, чтобы извлечь фактические значения, используемые для сортировки, во временный массив, отсортировать временный массив, а затем обойти временный массив для получения правильного порядка.",
	"func": "// массив для сортировки\nvar list = ['Дельта', 'альфа', 'ЧАРЛИ', 'браво'];\n\n// временный массив содержит объекты с позицией и значением сортировки\nvar mapped = list.map(function(el, i) { \nreturn { index: i, value: el.toLowerCase() }; \n});\n\n// сортируем массив, содержащий уменьшенные значения\nmapped.sort(function(a, b) { \n  if (a.value > b.value) { \n    return 1; } \n  if (a.value < b.value) { \n    return -1; } \n  return 0; \n});\n\n// контейнер для результа\nvar result = mapped.map(function(el) {\n  return list[el.index];\n});\n\ndocument.getElementById('sort').textContent = result;"
},
{
	"name": "splice",
	"description": "изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.",
	"func": "var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];\nvar removed = myFish.splice(2, 0, 'drum');\n\n// myFish равен [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"] \n// removed равен [], ничего не удалено\n\nvar myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];\nvar removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');\n\n// myFish равен [\"parrot\", \"anemone\", \"blue\", \"trumpet\", \"sturgeon\"] \n// removed равен [\"angel\", \"clown\"]\n\ndocument.getElementById('splice').textContent = myFish"
}
]